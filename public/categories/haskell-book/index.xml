<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Haskell Book - Category - JOATMON</title>
        <link>https://www.sassoli.io/categories/haskell-book/</link>
        <description>Haskell Book - Category - JOATMON</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>sassoli@gmail.com (Bernardino Sassoli)</managingEditor>
            <webMaster>sassoli@gmail.com (Bernardino Sassoli)</webMaster><copyright>copyright: Bernardino Sassoli 2022-</copyright><lastBuildDate>Sun, 02 Jul 2023 09:00:00 &#43;0200</lastBuildDate><atom:link href="https://www.sassoli.io/categories/haskell-book/" rel="self" type="application/rss+xml" /><item>
    <title>Haskell Book: Chapters 3 &amp; 4</title>
    <link>https://www.sassoli.io/haskell-book-part-2/</link>
    <pubDate>Sun, 02 Jul 2023 09:00:00 &#43;0200</pubDate>
    <author>Bernardino Sassoli</author>
    <guid>https://www.sassoli.io/haskell-book-part-2/</guid>
    <description><![CDATA[Chapter 3 type Char (in single quotes) vs type String (which is as usual syntactic sugar for a list of chars, hence String is a type alias for [Char])
need main when building a project with Stack
the IO () type, &ldquo;used when the result of running a program involves effects beyond evaluating a function or expression&rdquo;
print vs putStr vs putStrLn - the first just prints whatever to the display hence, the others are String specific (putStrLn will add a newline char):]]></description>
</item>
<item>
    <title>Haskell Book: Chapters 1 &amp; 2</title>
    <link>https://www.sassoli.io/haskell-book-part1/</link>
    <pubDate>Fri, 30 Jun 2023 12:13:35 &#43;0200</pubDate>
    <author>Bernardino Sassoli</author>
    <guid>https://www.sassoli.io/haskell-book-part1/</guid>
    <description><![CDATA[So this morning I got started with the Haskell book. Here are some notes and exercises.
Chapter 1 This is just a very short and simple introduction to the lambda calculus.
Syntax of λ-calculus 1 2 3 &lt;expression&gt; := &lt;name&gt; | &lt;function&gt; | &lt;application&gt; &lt;function&gt; := λ &lt;name&gt;.&lt;expression&gt; &lt;application&gt; := &lt;expression&gt;&lt;expression&gt; α-equivalence: basically the notion that $\lambda{x}.x$, $\lambda{y}.y$ and $\lambda{z}.z$ all express the same function. β-reduction: when you apply a function to some expression you replace all bound occurrences in the body with that expression and eliminate the head.]]></description>
</item>
</channel>
</rss>
