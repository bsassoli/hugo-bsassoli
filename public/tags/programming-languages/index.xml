<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>programming languages - Tag - JOATMON</title>
        <link>https://www.sassoli.io/tags/programming-languages/</link>
        <description>programming languages - Tag - JOATMON</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>sassoli@gmail.com (Bernardino Sassoli)</managingEditor>
            <webMaster>sassoli@gmail.com (Bernardino Sassoli)</webMaster><copyright>copyright: Bernardino Sassoli 2022-</copyright><lastBuildDate>Sun, 02 Jul 2023 09:00:00 &#43;0200</lastBuildDate><atom:link href="https://www.sassoli.io/tags/programming-languages/" rel="self" type="application/rss+xml" /><item>
    <title>Haskell Book: Chapters 3 &amp; 4</title>
    <link>https://www.sassoli.io/haskell-book-part-2/</link>
    <pubDate>Sun, 02 Jul 2023 09:00:00 &#43;0200</pubDate>
    <author>Bernardino Sassoli</author>
    <guid>https://www.sassoli.io/haskell-book-part-2/</guid>
    <description><![CDATA[Chapter 3 type Char (in single quotes) vs type String (which is as usual syntactic sugar for a list of chars, hence String is a type alias for [Char])
need main when building a project with Stack
the IO () type, &ldquo;used when the result of running a program involves effects beyond evaluating a function or expression&rdquo;
print vs putStr vs putStrLn - the first just prints whatever to the display hence, the others are String specific (putStrLn will add a newline char):]]></description>
</item>
<item>
    <title>Haskell Book: Chapter 1 Exercises</title>
    <link>https://www.sassoli.io/chapter-1-exercises/</link>
    <pubDate>Sat, 01 Jul 2023 07:07:59 &#43;0200</pubDate>
    <author>Bernardino Sassoli</author>
    <guid>https://www.sassoli.io/chapter-1-exercises/</guid>
    <description><![CDATA[Combinators 洧랝洧논.洧논洧논洧논 洧랝洧논洧녽.洧녾洧논 洧랝洧논洧녽洧녾.洧논洧녽(洧녾洧논) 洧랝洧논洧녽洧녾.洧논洧녽(洧녾洧논洧녽) 洧랝洧논洧녽.洧논洧녽(洧녾洧논洧녽) 2 and 5 are not combinators because in both cases $z$ appears free.
Normal form or diverge? 洧랝洧논.洧논洧논洧논 is already in normal form (洧랝洧녾.洧녾洧녾)(洧랝洧녽.洧녽洧녽) diverges since the first application to $z$ yields (洧랝洧녽.洧녽洧녽)(洧랝洧녽.洧녽洧녽) which is omega (洧랝洧논.洧논洧논洧논)洧녾 becomes 洧녾洧녾洧녾 -&gt; normal form Beta reduce (洧랝洧녩洧녪洧녫.洧녫洧녪洧녩)洧녾洧녾(洧랝洧녻洧녺.洧녻)
(洧랝洧녪洧녫.洧녫洧녪洧녾)(洧녾)(洧랝洧녻洧녺.洧녻)
(洧랝洧녫.洧녫洧녾洧녾)(洧랝洧녻洧녺.洧녻)
(洧랝洧녻洧녺.洧녻)(洧녾洧녾)
洧녾洧녾
(洧랝洧논.洧랝洧녽.洧논洧녽洧녽)(洧랝洧녩.洧녩)洧녪
(洧랝洧녽.(洧랝洧녩.洧녩)yy)(洧녪)
(洧랝洧녩.洧녩)洧녪洧녪
洧녪洧녪
(洧랝洧녽.洧녽)(洧랝洧논.洧논洧논)(洧랝洧녾.洧녾洧)
(洧랝洧논.洧논洧논)(洧랝洧녾.洧녾洧)
(洧랝洧녾.洧녾洧)(洧랝洧녾.洧녾洧)
(洧랝洧녾.洧녾洧)(洧)
洧륋롐
(洧랝洧녾.洧녾)(洧랝洧녾.洧녾洧녾)(洧랝洧녾.洧녾洧녽)
(洧랝洧녾.洧녾洧녾)(洧랝洧.洧륋롐)
(洧랝洧.洧륋롐)(洧랝洧.洧륋롐)
(洧랝洧.洧륋롐)(y)
yy
(洧랝洧논.洧랝洧녽.洧논洧녽洧녽)(洧랝洧녽.洧녽)洧녽]]></description>
</item>
<item>
    <title>Haskell Book: Chapters 1 &amp; 2</title>
    <link>https://www.sassoli.io/haskell-book-part1/</link>
    <pubDate>Fri, 30 Jun 2023 12:13:35 &#43;0200</pubDate>
    <author>Bernardino Sassoli</author>
    <guid>https://www.sassoli.io/haskell-book-part1/</guid>
    <description><![CDATA[So this morning I got started with the Haskell book. Here are some notes and exercises.
Chapter 1 This is just a very short and simple introduction to the lambda calculus.
Syntax of 풭-calculus 1 2 3 &lt;expression&gt; := &lt;name&gt; | &lt;function&gt; | &lt;application&gt; &lt;function&gt; := 풭 &lt;name&gt;.&lt;expression&gt; &lt;application&gt; := &lt;expression&gt;&lt;expression&gt; 풤-equivalence: basically the notion that $\lambda{x}.x$, $\lambda{y}.y$ and $\lambda{z}.z$ all express the same function. -reduction: when you apply a function to some expression you replace all bound occurrences in the body with that expression and eliminate the head.]]></description>
</item>
<item>
    <title>Beginning My Haskell Journey</title>
    <link>https://www.sassoli.io/beginning-my-haskell-journey/</link>
    <pubDate>Thu, 29 Jun 2023 18:04:08 &#43;0200</pubDate>
    <author>Bernardino Sassoli</author>
    <guid>https://www.sassoli.io/beginning-my-haskell-journey/</guid>
    <description><![CDATA[I&rsquo;ve been interested in functional programming languages for a while now. Having gone through some Scheme / Racket, some Elm as well as a little Standard ML, I guess I have no more excuse to procrastinate learning Haskell, which was the initial idea all along, basically. I am a little put off but all the horror stories about people who attempted to learn Haskell, unsuccessfully, many times over. So this series of posts will be my way to hold myself accountable and, if so be it, publicly acknowledge my shameful failure and my addition to the above mentioned heap of wannabee Haskellers.]]></description>
</item>
</channel>
</rss>
