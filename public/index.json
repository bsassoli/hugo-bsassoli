[{"categories":["Learning Haskell","Notes","Haskell Book"],"content":"Notes on chapters 3 and 4 of the Haskell book","date":"2023-07-02","objectID":"/haskell-book-part-2/","tags":["programming","programming languages","Haskell"],"title":"Haskell Book: Chapters 3 and 4","uri":"/haskell-book-part-2/"},{"categories":["Learning Haskell"],"content":"Combinators ğœ†ğ‘¥.ğ‘¥ğ‘¥ğ‘¥ ğœ†ğ‘¥ğ‘¦.ğ‘§ğ‘¥ ğœ†ğ‘¥ğ‘¦ğ‘§.ğ‘¥ğ‘¦(ğ‘§ğ‘¥) ğœ†ğ‘¥ğ‘¦ğ‘§.ğ‘¥ğ‘¦(ğ‘§ğ‘¥ğ‘¦) ğœ†ğ‘¥ğ‘¦.ğ‘¥ğ‘¦(ğ‘§ğ‘¥ğ‘¦) 2 and 5 are not combinators because in both cases $z$ appears free. ","date":"2023-07-01","objectID":"/chapter-1-exercises/:1:0","tags":["programming","programming languages","Haskell"],"title":"Haskell Book: Chapter 1 Exercises","uri":"/chapter-1-exercises/"},{"categories":["Learning Haskell"],"content":"Normal form or diverge? ğœ†ğ‘¥.ğ‘¥ğ‘¥ğ‘¥ is already in normal form (ğœ†ğ‘§.ğ‘§ğ‘§)(ğœ†ğ‘¦.ğ‘¦ğ‘¦) diverges since the first application to $z$ yields (ğœ†ğ‘¦.ğ‘¦ğ‘¦)(ğœ†ğ‘¦.ğ‘¦ğ‘¦) which is omega (ğœ†ğ‘¥.ğ‘¥ğ‘¥ğ‘¥)ğ‘§ becomes ğ‘§ğ‘§ğ‘§ -\u003e normal form ","date":"2023-07-01","objectID":"/chapter-1-exercises/:2:0","tags":["programming","programming languages","Haskell"],"title":"Haskell Book: Chapter 1 Exercises","uri":"/chapter-1-exercises/"},{"categories":["Learning Haskell"],"content":"Beta reduce (ğœ†ğ‘ğ‘ğ‘.ğ‘ğ‘ğ‘)ğ‘§ğ‘§(ğœ†ğ‘¤ğ‘£.ğ‘¤) (ğœ†ğ‘ğ‘.ğ‘ğ‘ğ‘§)(ğ‘§)(ğœ†ğ‘¤ğ‘£.ğ‘¤) (ğœ†ğ‘.ğ‘ğ‘§ğ‘§)(ğœ†ğ‘¤ğ‘£.ğ‘¤) (ğœ†ğ‘¤ğ‘£.ğ‘¤)(ğ‘§ğ‘§) ğ‘§ğ‘§ (ğœ†ğ‘¥.ğœ†ğ‘¦.ğ‘¥ğ‘¦ğ‘¦)(ğœ†ğ‘.ğ‘)ğ‘ (ğœ†ğ‘¦.(ğœ†ğ‘.ğ‘)yy)(ğ‘) (ğœ†ğ‘.ğ‘)ğ‘ğ‘ ğ‘ğ‘ (ğœ†ğ‘¦.ğ‘¦)(ğœ†ğ‘¥.ğ‘¥ğ‘¥)(ğœ†ğ‘§.ğ‘§ğ‘) (ğœ†ğ‘¥.ğ‘¥ğ‘¥)(ğœ†ğ‘§.ğ‘§ğ‘) (ğœ†ğ‘§.ğ‘§ğ‘)(ğœ†ğ‘§.ğ‘§ğ‘) (ğœ†ğ‘§.ğ‘§ğ‘)(ğ‘) ğ‘ğ‘ (ğœ†ğ‘§.ğ‘§)(ğœ†ğ‘§.ğ‘§ğ‘§)(ğœ†ğ‘§.ğ‘§ğ‘¦) (ğœ†ğ‘§.ğ‘§ğ‘§)(ğœ†ğ‘.ğ‘ğ‘¦) (ğœ†ğ‘.ğ‘ğ‘¦)(ğœ†ğ‘.ğ‘ğ‘¦) (ğœ†ğ‘.ğ‘ğ‘¦)(y) yy (ğœ†ğ‘¥.ğœ†ğ‘¦.ğ‘¥ğ‘¦ğ‘¦)(ğœ†ğ‘¦.ğ‘¦)ğ‘¦ (ğœ†ğ‘¥.ğœ†ğ‘¦.ğ‘¥ğ‘¦ğ‘¦)(ğœ†ğ‘.ğ‘)(ğ‘¦) (ğœ†ğ‘¦.(ğœ†ğ‘.ğ‘)ğ‘¦ğ‘¦)(ğ‘¦) ((ğœ†ğ‘.ğ‘)ğ‘¦)(ğ‘¦) ğ‘¦ğ‘¦ (ğœ†ğ‘.ğ‘ğ‘)(ğœ†ğ‘.ğ‘ğ‘)ğ‘ (ğœ†ğ‘.ğ‘ğ‘)(ğœ†ğ‘.ğ‘ğ‘)ğ‘ (ğœ†ğ‘.ğ‘ğ‘)(ğœ†ğ‘.ğ‘ğ‘)(ğ‘) (ğœ†ğ‘.ğ‘ğ‘)(ğ‘)(ğ‘) ğ‘ğ‘ğ‘ (ğœ†ğ‘¥ğ‘¦ğ‘§.ğ‘¥ğ‘§(ğ‘¦ğ‘§))(ğœ†ğ‘¥.ğ‘§)(ğœ†ğ‘¥.ğ‘) (ğœ†ğ‘¥.ğœ†ğ‘¦.ğœ†ğ‘§.ğ‘¥ğ‘§(ğ‘¦ğ‘§))(ğœ†ğ‘¥.ğ‘)(ğœ†ğ‘¥.ğ‘) (ğœ†ğ‘¦.ğœ†ğ‘§.(ğœ†ğ‘¥.ğ‘)(ğ‘§)(ğ‘¦ğ‘§))(ğœ†ğ‘¥.ğ‘) (ğœ†ğ‘§.(ğœ†ğ‘¥.ğ‘)(ğ‘§)((ğœ†ğ‘¥.ğ‘)ğ‘§)) (ğœ†ğ‘§.ğ‘(ğœ†ğ‘¥.ğ‘(ğ‘§))) (ğœ†ğ‘§.ğ‘ğ‘) ","date":"2023-07-01","objectID":"/chapter-1-exercises/:3:0","tags":["programming","programming languages","Haskell"],"title":"Haskell Book: Chapter 1 Exercises","uri":"/chapter-1-exercises/"},{"categories":["Learning Haskell","Notes","Haskell Book"],"content":"Notes on chapters 1 and 2 of the Haskell book","date":"2023-06-30","objectID":"/haskell-book-part1/","tags":["programming","programming languages","Haskell"],"title":"Haskell Book: Chapters 1 \u0026 2","uri":"/haskell-book-part1/"},{"categories":["Learning Haskell","Notes","Haskell Book"],"content":"So this morning I got started with the Haskell book. Here are some notes and exercises. ","date":"2023-06-30","objectID":"/haskell-book-part1/:0:0","tags":["programming","programming languages","Haskell"],"title":"Haskell Book: Chapters 1 \u0026 2","uri":"/haskell-book-part1/"},{"categories":["Learning Haskell","Notes","Haskell Book"],"content":"Chapter 1 This is just a very short and simple introduction to the lambda calculus. Syntax of Î»-calculus \u003cexpression\u003e := \u003cname\u003e | \u003cfunction\u003e | \u003capplication\u003e \u003cfunction\u003e := Î» \u003cname\u003e.\u003cexpression\u003e \u003capplication\u003e := \u003cexpression\u003e\u003cexpression\u003e Î±-equivalence: basically the notion that $\\lambda{x}.x$, $\\lambda{y}.y$ and $\\lambda{z}.z$ all express the same function. Î²-reduction: when you apply a function to some expression you replace all bound occurrences in the body with that expression and eliminate the head. To indicate that we are substituting e.g. $x$ with $z$ in $\\lambda{x}.x$ we write: $$[x := z]$$ Applications are left-associative: $$(\\lambda{x}.x)(\\lambda{y}.y)z$$ is equivalent to $$((\\lambda{x}.x)(\\lambda{y}.y))z$$ Each lambda can only bind one parameter and can only accept one argument. Functions that require multiple arguments have multiple, nested heads. This is known as currying A combinator is a lambda term with no free variables Î² normal form. Beta normal form is when you cannot beta reduce (apply lambdas to arguments) the terms any further. This corresponds to a fully evaluated expression, or, in programming, a fully executed program. Some expressions diverge, e.g. not all reducible lambda terms reduce to a normal form. This isnâ€™t because theyâ€™re already fully reduced, but because they diverge. E.g. the omega expression (ğœ†ğ‘¥.ğ‘¥ğ‘¥)(ğœ†ğ‘¥.ğ‘¥ğ‘¥) diverges. semantically, Haskell is a lambda calculus. Actually, Haskell is a typed lambda calculusâ€”more on types laterâ€” with a lot of surface-level decoration sprinkled on top, to make it easier for humans to write, but the semantics of the core language are the same as the lambda calculus. That is, the meaning of Haskell programs is centered around evaluating expressions. ","date":"2023-06-30","objectID":"/haskell-book-part1/:1:0","tags":["programming","programming languages","Haskell"],"title":"Haskell Book: Chapters 1 \u0026 2","uri":"/haskell-book-part1/"},{"categories":["Learning Haskell","Notes","Haskell Book"],"content":"Exercises ","date":"2023-06-30","objectID":"/haskell-book-part1/:1:1","tags":["programming","programming languages","Haskell"],"title":"Haskell Book: Chapters 1 \u0026 2","uri":"/haskell-book-part1/"},{"categories":["Learning Haskell","Notes","Haskell Book"],"content":"Chapter 2 sayHello :: String -\u003e IO() sayHello x = \"hello \" ++ x Most of this wasnâ€™t new. But it pushed me to clarify what is meant by â€œpureâ€ function which is a somewhat confusing notion. So all of these are impiure functions in Python. a = 20 def impure1(): global a a = a + 20 impure1() print(a) # no return, calling it will cause changes to a which is outside it's scope num = 10 def impure2(): print(num) impure2() # no return, changing num will change it's behaviour even though num isn't an argument to impure num3 = 10 def impure3 (num1, num2): x = (num1 + num2) / num3 return x print(impure3(2, 3)) # returns a value but what it returns depends on something that's not an argument Other than that: REPL + ghci infixing with backticks and prefixing with parens association and precedence (with :info) let vs where ","date":"2023-06-30","objectID":"/haskell-book-part1/:2:0","tags":["programming","programming languages","Haskell"],"title":"Haskell Book: Chapters 1 \u0026 2","uri":"/haskell-book-part1/"},{"categories":["Learning Haskell"],"content":"My resolution to start learning Haskell.","date":"2023-06-29","objectID":"/beginning-my-haskell-journey/","tags":["programming","programming languages","Haskell"],"title":"Beginning My Haskell Journey","uri":"/beginning-my-haskell-journey/"},{"categories":["Learning Haskell"],"content":"Iâ€™ve been interested in functional programming languages for a while now. Having gone through some Scheme / Racket, some Elm as well as a little Standard ML, I guess I have no more excuse to procrastinate learning Haskell, which was the initial idea all along, basically. I am a little put off but all the horror stories about people who attempted to learn Haskell, unsuccessfully, many times over. So this series of posts will be my way to hold myself accountable and, if so be it, publicly acknowledge my shameful failure and my addition to the above mentioned heap of wannabee Haskellers. Right now I am quite unsure about whether I should go. One route is to just go through the Haskell book as many seem to be suggesting. Another, more project-based and maybe more suited to me, would be to follow this. I think a mix of the two approaches might be the best thing, but then Iâ€™d probably get lost - as usual - by doing more than one thing at a time. To add to my confusion, there is this resourceâ€¦. ","date":"2023-06-29","objectID":"/beginning-my-haskell-journey/:0:0","tags":["programming","programming languages","Haskell"],"title":"Beginning My Haskell Journey","uri":"/beginning-my-haskell-journey/"},{"categories":["Ramblings"],"content":"I probably should get my act together and actually read and study SICP. ","date":"2023-03-09","objectID":"/reading-sicp/:0:0","tags":["programming","SICP"],"title":"Berni's adventures in SICPland","uri":"/reading-sicp/"},{"categories":null,"content":"About me ","date":"0001-01-01","objectID":"/about/:0:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"TLDR I am Bernardino, and I am a JOATMON (Jack Of All Trades, Master of None) from Milan, Italy. I built this site mostly as a personal blog to document my journey as a self-taught 50+ computer programmer. Trained as a philosopher, I work as a management consultant. ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Computer stuff When it comes to computers my main areas of interest lie in AI (I am, by the way, a Google Certified Tensorflow Developer) and functional programming. I am on the Advisory Board of deepers.ai, an AI education/consulting platform, and in my extra-time I lead the Italian chapter of Omdena, a platform that helps crowdsource ML/AI products for NGOs, impact and ESG projects. I occasionally write about artificial intelligence and computer science, e.g.: How to build a neural network from zero is, well, pretty self-explanatory Want to get good at recursion? Here is my advice (basically a review of the wonderful The Little Schemer book). You can read my articles on Â  Medium. ","date":"0001-01-01","objectID":"/about/:2:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Personal and varia I have a beloved son who is currently a student at Bocconi University and I am married with lovely Stephanie. Stephanie and I adopted a Maremma / Retriever Mix named Jonny in 2021 and are very, very, fond of him. I am a voracious music lover, an avid book reader, and a not very good guitar player. ","date":"0001-01-01","objectID":"/about/:3:0","tags":null,"title":"","uri":"/about/"},{"categories":null,"content":"Projects Here is some stuff I have been fooling around with. Milan Culture Mapp is a webapp I built when I was collaborating with the Municipality of Milano on a project mapping the cityâ€™s cultural venues. The backend is built in Django, the frontend is vanilla JS and the interactive map is rendered in Folium. ReviewGeek is a small project I did in a weekend for an acquaintance of mine who signaled they wanted a better way to keep track of TripAdvisor reviews for their restaurants. It is built in Streamlit. A bare bones calculator I built as a React exercise. ","date":"0001-01-01","objectID":"/projects/:0:0","tags":null,"title":"","uri":"/projects/"}]